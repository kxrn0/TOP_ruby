Given the context I think I will need to use a graph, and the depth first search algorithm to find the closest path. 
I can hardcode the moves, and check that they are in bounds. If I have an nxn board, I can write a function to get all
possible moves from a cell [x, y]

function get_moves cell, size
  hardcoded = [
    { x: -2, y: -1 },
    { x: -1, y: -2 },
    { x: 1, y: -2 },
    { x: 2, y: -1 },
    { x : 2, y: 1 },
    { x: 1, y: 2 },
    { x: -1, y: 2 },
    { x: -2, y: 1 }
  ]
  moves = []

  for let move of hardcoded {
    move = { x: move.x + cell.x, y: move.y + cell.y }

    if 0 <= x <= size && 0 <= y <= size
      moves.push move
  }

  return moves
end

I have a cell C = { x, y }, and a set of moves I can make. With breadth level traversal I would visit each of the cells
those moves would take me to, and if any of those were the target cell, I would return something, otherwise I would then visit 
the cells I can get to from those places, and so on until there are no more places to visit. I need to keep track of which
cells I have visited for a given route, so I don't visit them again. If the coordinates of the target cell are within the
dimensions of the board, then the target cell is guaranteed to be reached. I could have a check for this, but for simplicity won't,
or if so, it will be until the end.

I have all the moves I can do from the starting position. For each one, I create a path array that will keep track of the steps
moves I make. I shove the starting position into each one of those arrays, and next the move.
